<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python 中的异常日志（译）</title>
      <link href="/2018/04/10/exceptional-logging-of-exceptions-in-python/"/>
      <url>/2018/04/10/exceptional-logging-of-exceptions-in-python/</url>
      <content type="html"><![CDATA[<p>本文的作者 Aaron Maxwell 同时也是 <a href="https://powerfulpython.com/" target="_blank" rel="noopener">Powerful Python</a> 的作者.</p><p>异常在代码中无处不在。 作为一个开发者，我们总得面对异常处理这一问题。就算是在写一个帮人们找墨西哥卷饼的工具。</p><p>哈哈，回到正题。就像我常说的：如何处理异常取决于你使用的编程语言。在运维有一定规模的应用程序时, 日志是最强大最有价值的工具之一。 我们来看看有哪些记录异常日志的方式。</p><h2 id="big-tarp- 不管三七二十一全 -catch- 了式"><a class="header-anchor" href="#big-tarp- 不管三七二十一全 -catch- 了式"></a>“Big Tarp” 不管三七二十一全 catch 了式</h2><p>我们从一个比较极端的例子开始讲起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    main_loop()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    logger.exception(<span class="string">"Fatal error in main loop"</span>)</span><br></pre></td></tr></table></figure><p>这个 try-except 会捕获所有异常。 这种异常捕获方式适合用在那些可能会抛出一些你无法预知的异常的代码块上 (比如 main_loop())。与其让应用就这样崩溃，你可以选择捕获并用日志记录下这一异常，继续让应用运行下去。</p><p>这里比较 magic 的地方是选择使用 <code>logger.exception</code> 方法 (logger 是调用 logging.getLogger() 返回的一个实例)。这个棒棒的方法会记录下代码块完整的异常栈追踪信息并完整的输出出来。</p><p>可以注意到的是这里我们并不需要将异常对象传给 exception 方法，只需要传一个 logging message 字符串。message 会出现在第一行，然后输出完整的异常栈。异常发生时，代码的输出看起来会像是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fatal error in main loop</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;bigtarp.py&quot;, line 14, in</span><br><span class="line">    main_loop()</span><br><span class="line">  File &quot;bigtarp.py&quot;, line 9, in main_loop</span><br><span class="line">    print(foo(x))</span><br><span class="line">  File &quot;bigtarp.py&quot;, line 4, in foo</span><br><span class="line">    return 10 // n</span><br><span class="line">ZeroDivisionError: integer division or modulo by zero</span><br></pre></td></tr></table></figure><p>这里的演示都是示例用简单代码的输出，细节并不重要。 只需要注意到第一行是我们传给 <code>logger.exception()</code> 方法的 <code>message</code>，后面那些行都是异常栈，最后一行是异常类型 (例子中是 <code>ZeroDivisionError</code>)。这种捕捉记录方式会捕获任何异常并这样打印出来。</p><p><code>logger.exception</code> 方法默认的日志级别是 ERROR。你也可以使用其他常用的 logging 方法 <code>logger.debug()</code>、 <code>logger.info()</code>、 <code>logger.warn()</code> 等等，并传一个 <code>exc_info</code> 参数，值为 <code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main_loop()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        logger.error(<span class="string">"Fatal error in main loop"</span>, exc_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>将 <code>exc_info</code> 参数设置为 <code>True</code> 会导致 logging 记录下完整的 stack trace…。 和 logger.exception() 的行为完全一致. 唯一的不同是这样你可以更方便的指定日志级别。</p><p>有趣的地方： 与 Big Tarp 形式对应的，有一个几乎完全相反的形式，接下来你就会看到。</p><h2 id="pinpoint- 细粒度式"><a class="header-anchor" href="#pinpoint- 细粒度式"></a>“Pinpoint” 细粒度式</h2><p>现在我们来看另一个比较极端的例子。 假设你在写一个叫做 OpenBurrito 的 SDK -- 一个来解决“如何在深夜的时候在你的附近找到一家墨西哥卷饼摊”这个棘手问题的库。假设它有一个函数叫做 <code>find_burrito_joints()</code>，它可以返回一个包含有合适餐馆信息的列表。在极少的情况下，这个函数会抛出一个异常：<code>BurritoCriteriaConflict</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openburrito <span class="keyword">import</span> find_burrito_joints, BurritoCriteriaConflict</span><br><span class="line"><span class="comment"># "criteria" is an object defining the kind of burritos you want.</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    places = find_burrito_joints(criteria)</span><br><span class="line"><span class="keyword">except</span> BurritoCriteriaConflict <span class="keyword">as</span> err:</span><br><span class="line">    logger.warn(<span class="string">"Cannot resolve conflicting burrito criteria: &#123;&#125;"</span>.format(err.message))</span><br><span class="line">    places = list()</span><br></pre></td></tr></table></figure><p>这里的方法是通过加上一个 try-except 块来乐观的去执行函数 find_burrito_joints()。 执行的过程中抛出了一个 <code>BurritoCriteriaConflict</code> 异常，你用日志记录下了这个异常，解决了问题，继续执行下去。</p><p>关键的不同点是这里的 except 语句. 在 Big Tarp 形式中，你基本上是捕获了任意类型的异常；在 Pinpoint 形式下，你捕获了一个非常明确类型的异常，这个异常很语义化的反映了代码中的一个部分。</p><p>同样也注意到，这里我是用了 <code>logger.warn()</code> 而不是 <code>logger.exception()</code>（这篇文章中的 <code>warn()</code> 都可以被替换为 <code>info()</code>，或 <code>error()</code> 等等）。换句话说，我在一个确认的日志级别下记录了异常发生的信息，而不是记录下一整个异常栈。</p><p>为什么我不去记录下整个异常栈呢？因为在这种情况下，异常栈并没有什么用处。我捕获的是一个非常明确的异常类型，它在代码逻辑中有非常明确的含义。比如，下面这一小段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">characters = &#123;<span class="string">"hero"</span>: <span class="string">"Homer"</span>, <span class="string">"villain"</span>: <span class="string">"Mr. Burns"</span>&#125;</span><br><span class="line"><span class="comment"># Insert some code here that may or may not add a key called</span></span><br><span class="line"><span class="comment"># "sidekick" to the characters dictionary.</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sidekick = characters[<span class="string">"sidekick"</span>]</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    sidekick = <span class="string">"Milhouse"</span></span><br></pre></td></tr></table></figure><p>这里，<code>KeyError</code> 不仅仅是一个错误，当它被抛出的时候意味着一个非常明确的条件被触发了：“sidekick” 在我定义的 characters 中是不存在的，所以我选择取一个默认值。 让日志中充满异常栈在这种情况下并没有任何帮助，这时候你就需要使用 Pinpoint 形式了。</p><h2 id="transformer- 转换异常类型式"><a class="header-anchor" href="#transformer- 转换异常类型式"></a>“Transformer” 转换异常类型式</h2><p>捕获一个异常，给它打日志，然后重新跑出另一个类型的异常。</p><p>首先，在 Python 3 中它是这样工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> SomeError <span class="keyword">as</span> err:</span><br><span class="line">    logger.warn(<span class="string">"..."</span>)</span><br><span class="line">    <span class="keyword">raise</span> DifferentError() <span class="keyword">from</span> err</span><br></pre></td></tr></table></figure><p>在 Python 2 中你得去掉 <code>from err</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> SomeError <span class="keyword">as</span> err:</span><br><span class="line">    logger.warn(<span class="string">"..."</span>)</span><br><span class="line">    <span class="keyword">raise</span> DifferentError()</span><br></pre></td></tr></table></figure><p>(这里蕴含了很多信息，多思考一会儿...) 在原先代码抛出的异常不是很符合你程序的逻辑的时候，你会需要这种异常处理方法。这经常发生在库与库的边界上。</p><p>比如，假设你在使用 openBurrito SDK 制作一个帮人们寻找深夜卷饼摊的“杀手级”应用，如果我们过于挑剔 <code>find_burrito_joints()</code> 函数可能会抛出一个 <code>BurritoCriteriaConflict</code> 异常。这是 SDK 暴露出的 API，但是它不能方便的对应到你代码中高层的逻辑。更合适的是在这里能抛出一个你自己定义的异常类型，叫做 <code>NoMatchingRestaurants</code>。</p><p>这种情况下，你需要采用下面这种形式 (针对 Python 3):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myexceptions <span class="keyword">import</span> NoMatchingRestaurants</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    places = find_burrito_joints(criteria)</span><br><span class="line"><span class="keyword">except</span> BurritoCriteriaConflict <span class="keyword">as</span> err:</span><br><span class="line">    logger.warn(<span class="string">"Cannot resolve conflicting burrito criteria: &#123;&#125;"</span>.format(err.message))</span><br><span class="line">    <span class="keyword">raise</span> NoMatchingRestaurants(criteria) <span class="keyword">from</span> err</span><br></pre></td></tr></table></figure><p>这会输出一个单行日志，并抛出一个新的异常。如果这个新异常没有被捕获，那么错误输出看起来会是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;transformerB3.py&quot;, line 8, in</span><br><span class="line">    places = find_burrito_joints(criteria)</span><br><span class="line">  File &quot;/Users/amax/python-exception-logging-patterns/openburrito.py&quot;, line 7, in find_burrito_joints</span><br><span class="line">    raise BurritoCriteriaConflict</span><br><span class="line">openburrito.BurritoCriteriaConflict</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;transformerB3.py&quot;, line 11, in</span><br><span class="line">    raise NoMatchingRestaurants(criteria) from err</span><br><span class="line">myexceptions.NoMatchingRestaurants: &#123;&apos;region&apos;: &apos;Chiapas&apos;&#125;</span><br></pre></td></tr></table></figure><p>这里就有趣了。输出中包含了 <code>NoMatchingRestaurants</code> 的异常栈，同时也输出了造成这一异常的 <code>BurritoCriteriaConflict</code> 的异常栈…… 非常清楚的表明了谁是最初的异常。</p><p>在 Python 3 中，<code>raise … from … 语法使异常可以被链起来。当你写 </code>raise NoMatchingRestaurants(criteria) from err<code>，会抛出一个</code>NoMatchingRestaurants<code> 类型的异常，这个异常对象有一个叫做</code><strong>cause</strong>` 的属性，值指向它的父 exception。 Python 3 内部在报告异常的时候会默认采取这种方式。</p><p>能不能在 Python 2 中实现这一特性呢 ？好吧，你不能。这就是那些你需要升级才能享受到的好东西。Python 2 不支持 <code>raise … from</code> 这样的语法, 你的异常输出只会包括 <code>NoMatchingRestaurants</code> 的异常栈。当然，“Transformer” 仍然能够完美的使用。</p><h2 id="message-and-raise- 记一下再抛出来式"><a class="header-anchor" href="#message-and-raise- 记一下再抛出来式"></a>“Message and Raise” 记一下再抛出来式</h2><p>这种形式下，你在某个点给发生的异常打一个日志，不作处理直接抛出，将异常交给更外层的代码来处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> SomeError:</span><br><span class="line">    logger.warn(<span class="string">"..."</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>你并没有真正意义上的“处理”这个错误，你只是暂时中断了异常抛出并打了一个日志。 当你在外层代码的确有处理这个错误的时候，你想把代码交给外层处理，但又想在代码特定的位置用日志记录这次异常的发生，或者这个异常的含义，可以用这种形式。</p><p>这在你查找异常原因，尝试去理解异常发生的上下文的时候非常有用。你可以插入这种 logging 语句来提供有用的信息，或者你想在真实的场景下安全的监控代码的执行结果。</p><h2 id="cryptic-message- 打出迷之日志的反形式"><a class="header-anchor" href="#cryptic-message- 打出迷之日志的反形式"></a>“Cryptic Message” 打出迷之日志的反形式</h2><p>现在我们把注意力放到一些“反形式”上… 请不要在你的代码里用这种形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    logger.error(<span class="string">"..."</span>)</span><br></pre></td></tr></table></figure><p>假设你团队的其他成员写了这种代码，半年后，你看到一个搞笑的日志消息，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: something bad happened</span><br></pre></td></tr></table></figure><p>我希望和祈祷你在你真实的代码中不会遇到 “something bad happened”。然而，你可能会碰到一样很莫名其妙的日志消息，你会怎么办呢？</p><p>好吧，首先你需要找到到底是哪一行代码抛出了这个模糊的信息。如果你运气好，grep 以下代码就找到了确切的那一行；你可能在好几个完全不同的地方找到可能抛出这个异常的代码。这会带给你好几个问题：</p><p>到底是哪一行触发了异常？</p><p>或者是其中几行触发的？</p><p>或者是所有这些？</p><p>这个日志代表了代码中的哪里？</p><p>然而有些时候你根本无法通过 grep 找到异常发生的地方，因为 log 信息是生成出来的。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">what = <span class="string">"something"</span></span><br><span class="line">quality = <span class="string">"bad"</span></span><br><span class="line">event = <span class="string">"happened"</span></span><br><span class="line">logger.error(<span class="string">"%s %s %s"</span>, what, quality, event)</span><br></pre></td></tr></table></figure><p>你怎么通过日志来搜索？如果不是你搜遍了代码也没找到匹配日志信息的那一行，你可能根本不会想到这个问题。就算你找到了，也很可能是个错的位置。</p><p>最好的办法是传一个 <code>exc_info</code> 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    logger.error(<span class="string">"something bad happened"</span>, exc_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>这样做可以让日志中包含异常栈追踪，告诉你到底是代码中的那部分抛出了异常，谁调用的它 等等… 你排错需要的所有信息都在这。</p><h2 id="最邪恶的 -python- 反形式"><a class="header-anchor" href="# 最邪恶的 -python- 反形式"></a>最邪恶的 Python 反形式</h2><p>如果让我看见你写这样的东西，我会冲到你家没收你的电脑，然后黑进你的 Github 账号删掉你所有的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在我的文章，我把这个叫做 “最邪恶的 Python 反形式（The Most Diabolical Python Antipattern）”。 这段代码在发生异常的时候不会给你任何信息，而且源头上隐藏了可能发生的任何错误。你可能都不会知道你敲错了一个变量名，其实这最终会造成一个 NameError —— 当你凌晨两点收到告警告知你的生产环境崩掉了，然后花掉你一个通宵来找寻问题原因，因为定位问题需要的信息都被隐藏掉了。</p><p>就记住不要干这种事，如果你觉得你需要简单的捕获所有异常并忽略掉，最少用个 “big tarp” （比如使用 <code>logger.exception()</code> 而不是 <code>pass</code>）</p><h2 id="更多异常日志形式"><a class="header-anchor" href="# 更多异常日志形式"></a>更多异常日志形式</h2><p>Python 中还有更多处理异常的形式，各有各的代价，各有各的优缺点。你知道还有什么有用的形式么？欢迎在文章下面留下评论分享。</p><p>原文链接：<a href="https://www.loggly.com/blog/exceptional-logging-of-exceptions-in-python" target="_blank" rel="noopener">https://www.loggly.com/blog/exceptional-logging-of-exceptions-in-python</a></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker Engine 的 RESTful API 版本管理策略</title>
      <link href="/2017/06/07/restful-api-version-management-strategy-of-docker-engine/"/>
      <url>/2017/06/07/restful-api-version-management-strategy-of-docker-engine/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/moby/moby" target="_blank" rel="noopener">Docker</a> 项目是一个标准的 C/S 架构，Docker Daemon（二进制为 dockerd） 作为 Server，其他诸如 Docker Client、docker-py 等则作为 Client。Daemon 提供了一套 RESTful API 供客户端使用。经过多年的发展，Docker 的版本号发生了大变革，变成了日期命名并且已经到了 17.05 版本，Docker 项目甚至改名成了 Moby。但 Docker 的 API 却一直保证了良好的兼容性，有着完善的版本管理策略和文档。</p><p>本文将就 Docker Engine 的 API 版本管理策略展开讨论。</p><h2 id="代码版本和 -api- 版本相互独立"><a class="header-anchor" href="# 代码版本和 -api- 版本相互独立"></a>代码版本和 API 版本相互独立</h2><p>在命令行中执行 <code>docker version</code> 我们可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"></span><br><span class="line">Client:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Wed Apr  5 06:06:36 2017</span><br><span class="line"> OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Tue Apr  4 00:37:25 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Client 和 Server 除了本身的 Version 外还有一个 API Version。实时上 Docker 的 API 版本和代码的版本是完全相互独立的，虽然每个代码版本都会唯一对应一个 API 版本，但 API 版本并不会随着代码版本变更。我们翻看 Docker 官网的文档可以发现罗列的从 v1.1.8 开始的各个 API 版本。</p><p>每个版本所有 API 都属同一版本，用户可以通过 <code>/info</code> 来访问，也可以通过 <code>/v1.28/info</code> 来访问 API。</p><h2 id="文档定义版本"><a class="header-anchor" href="# 文档定义版本"></a>文档定义版本</h2><p>看到如此多的 API 版本和复杂的变更，我们会想，在代码层面 Docker（moby） 项目是如何标记这么多版本的 API 兼容，变更，丢弃的呢？</p><p>答案是：并没有，除了极少数 API 在代码中会根据版本有特殊处理外，兼容、变更、丢弃都没有体现在代码里。</p><p>那么这么详细的文档怎么生成的呢？</p><p>答案是：纯手写，Docker 项目并没有使用各种先进的自动文档生成工具，而是采用全部人工编写的方式。</p><p>每个版本的 API 都是用文档来定义的，Docker 项目对于文档非常重视，他们甚至有专职的文档工程师。这些文档都位于项目的 <a href="https://github.com/moby/moby/tree/master/docs/api" target="_blank" rel="noopener">docs/api</a> 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tree docs/api</span><br><span class="line">docs/api</span><br><span class="line">├── v1.18.md</span><br><span class="line">├── v1.19.md</span><br><span class="line">├── v1.20.md</span><br><span class="line">├── v1.21.md</span><br><span class="line">├── v1.22.md</span><br><span class="line">├── v1.23.md</span><br><span class="line">├── v1.24.md</span><br><span class="line">└── version-history.md</span><br><span class="line"></span><br><span class="line">0 directories, 8 files</span><br></pre></td></tr></table></figure><p>我们可以看到这里有各个版本的文档，还有一个 <code>version-history.md</code> 标记了每个版本的变更，这些文档都是手动编写的。Docker 项目有着非常严格的 Git 工作流，每个 Pull Request 如果涉及到 API 内容的变更都必须要修改文档并让文档经过文档工程师的 Review 才能合并到主线。</p><h2 id="由客户端处理"><a class="header-anchor" href="# 由客户端处理"></a>由客户端处理</h2><p>既然代码里没有处理，只提供了文档，那么就得客户端来判断 API 的兼容、变更、丢弃了。</p><p>拿官方 Python 客户端 <a href="https://github.com/docker/docker-py/" target="_blank" rel="noopener">docker-py</a> 来说，我们看列出网络 API 的 <a href="https://github.com/docker/docker-py/blob/master/docker/api/network.py" target="_blank" rel="noopener"> 代码</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker/api/network.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkApiMixin</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @minimum_version('1.21')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networks</span><span class="params">(self, names=None, ids=None, filters=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        List networks. Similar to the ``docker networks ls`` command.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            names (:py:class:`list`): List of names to filter by</span></span><br><span class="line"><span class="string">            ids (:py:class:`list`): List of ids to filter by</span></span><br><span class="line"><span class="string">            filters (dict): Filters to be processed on the network list.</span></span><br><span class="line"><span class="string">                Available filters:</span></span><br><span class="line"><span class="string">                - ``driver=[&lt;driver-name&gt;]`` Matches a network's driver.</span></span><br><span class="line"><span class="string">                - ``label=[&lt;key&gt;]`` or ``label=[&lt;key&gt;=&lt;value&gt;]``.</span></span><br><span class="line"><span class="string">                - ``type=["custom"|"builtin"]`` Filters networks by type.</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            (dict): List of network objects.</span></span><br><span class="line"><span class="string">        Raises:</span></span><br><span class="line"><span class="string">            :py:class:`docker.errors.APIError`</span></span><br><span class="line"><span class="string">                If the server returns an error.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> filters <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            filters = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> names:</span><br><span class="line">            filters[<span class="string">'name'</span>] = names</span><br><span class="line">        <span class="keyword">if</span> ids:</span><br><span class="line">            filters[<span class="string">'id'</span>] = ids</span><br><span class="line">        params = &#123;<span class="string">'filters'</span>: utils.convert_filters(filters)&#125;</span><br><span class="line">        url = self._url(<span class="string">"/networks"</span>)</span><br><span class="line">        res = self._get(url, params=params)</span><br><span class="line">        <span class="keyword">return</span> self._result(res, json=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>我们注意到 <code>networks</code> 方法有一个 <code>@minimum_version('1.21')</code> 装饰器，根据文档的记述标记了 networks 是从哪个 API 版本开始引入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker/utils/decorators.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum_version</span><span class="params">(version)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> utils.version_lt(self._version, version):</span><br><span class="line">                <span class="keyword">raise</span> errors.InvalidVersion(</span><br><span class="line">                    <span class="string">'&#123;0&#125; is not available for version &lt; &#123;1&#125;'</span>.format(</span><br><span class="line">                        f.__name__, version</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> f(self, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>在访问这些 API 的时候客户端会检测服务端的 API 版本是否满足最小版本要求，不满足则会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> utils.version_lt(self._version, MINIMUM_DOCKER_API_VERSION):</span><br><span class="line">    warnings.warn(</span><br><span class="line">        <span class="string">'The minimum API version supported is &#123;&#125;, but you are using'</span></span><br><span class="line">        <span class="string">'version &#123;&#125;. It is recommended you either upgrade Docker'</span></span><br><span class="line">        <span class="string">'Engine or use an older version of Docker SDK for'</span></span><br><span class="line">        <span class="string">'Python.'</span>.format(MINIMUM_DOCKER_API_VERSION, self._version)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>Client 类实例化的时候通过指定或者访问 Docker 的 <code>/version</code> 接口自动得到 API 版本，并且会检查版本是否满足要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker/constants.py</span></span><br><span class="line">DEFAULT_DOCKER_API_VERSION = <span class="string">'1.26'</span></span><br><span class="line">MINIMUM_DOCKER_API_VERSION = <span class="string">'1.21'</span></span><br></pre></td></tr></table></figure><p>客户端定义了自己兼容的最低版本.</p><h2 id="api- 设计的原则"><a class="header-anchor" href="#api- 设计的原则"></a>API 设计的原则</h2><ol><li>严格撰写文档，写清楚每一个返回值和返回指定类型，标明每个可能的 HTTP Error 和相应的 Status Code。Docker Engine API 在 v1.25 之后使用 <a href="http://swagger.io/" target="_blank" rel="noopener">swagger</a> 来生成易读的文档页面，swagger 还能自动生成客户端示例代码</li><li>一旦 API 版本定下来绝对不要修改 API</li><li>设计 API 的时候要考虑兼容性，并且尽量不要去改动原来的 API。API 变化优先做法由高到低是：不改 &gt; 增加 API &gt; 添加旧 API 的字段 &gt; 修改 Endpoint &gt; 修改旧 API 的字段。增加的新字段最好给 CUD 方法加上默认值</li><li>设计 API 要有一定前瞻性，不要频繁发布新版本</li></ol><h2 id="总结"><a class="header-anchor" href="# 总结"></a>总结</h2><p>Docker 的 API 管理是一个比较成功的范例，他没有使用 “先进” 的自动化 API 工具，而是用流程、规范来管理这么数量庞大的 API。在保证文档完整正确的同时也非常灵活。值得我们的借鉴。</p>]]></content>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
